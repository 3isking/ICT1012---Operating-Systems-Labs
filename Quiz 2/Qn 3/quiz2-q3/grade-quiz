#!/usr/bin/env python3

import re
import subprocess
from gradelib import *


r = Runner(save("xv6.out"))

@test(2, "uthread_0")
def test_uthread_0():
    r.run_qemu(shell_script([
        'uthread_ex0'
    ]))
    # 1. Start with the initial startup messages
    expected = ['thread_a started', 'thread_b started', 'thread_c started']
    
    # 2. Add thread_a's sequential execution
    expected.extend(['thread_a %d' % n for n in range(3)])
    expected.append('thread_a: exit after 3')
    
    # 3. Add thread_b's sequential execution
    expected.extend(['thread_b %d' % n for n in range(3)])
    expected.append('thread_b: exit after 3')
    
    # 4. Add thread_c's sequential execution
    expected.extend(['thread_c %d' % n for n in range(3)])
    expected.append('thread_c: exit after 3')
    
    # 5. Add the final scheduler message
    expected.append('thread_schedule: no runnable threads')
    
    if not re.findall('\n'.join(expected), r.qemu.output, re.M):
        raise AssertionError('Output does not match expected output')

@test(1, "uthread_1")
def test_uthread_1():
    r.run_qemu(shell_script([
        'uthread_ex1'
    ]))
    # 1. Start with the initial startup messages
    expected = ['thread_a started', 'thread_b started', 'thread_c started']
    
    # 2. Add thread_a's end
    expected.append('thread_a: exit after 3')
    
    # 3. Add error invoking wake up
    expected.append('Error thread doesn\'t exist or it is not sleeping')
    expected.append('Error thread doesn\'t exist or it is not sleeping')

    # 4. Add trhead_b's end
    expected.append('thread_b: exit after 3')
    
    # 5. Add trhead_c's end
    expected.append('thread_c: exit after 3')
    
    # 6. Add the final scheduler message
    expected.append('thread_schedule: no runnable threads')
    
    if not re.findall('\n'.join(expected), r.qemu.output, re.M):
        raise AssertionError('Output does not match expected output')


@test(2, "uthread_2")
def test_uthread_2():
    r.run_qemu(shell_script([
        'uthread_ex2'
    ]))
    # 1. Start with the initial startup messages
    expected = ['thread_a started', 'thread_b started', 'thread_c started']
    
    # 2. Add thread_a's sequential execution
    expected.extend(['thread_a %d' % n for n in range(3)])
    expected.append('thread_a: exit after 3')
    
    # 3. Add thread_b's sequential execution
    expected.extend(['thread_b %d' % n for n in range(3)])
    expected.append('thread_b: exit after 3')
    
    # 4. Add thread_c's sequential execution
    expected.extend(['thread_c %d' % n for n in range(3)])

    # 5. Add thread_c's sequential execution
    expected.append('only thread sleepings, wake them all')

    #6. Add thread_c's exit message
    expected.append('thread_c: exit after 3')
    
    # 7. Add the final scheduler message 
    expected.append('thread_schedule: no runnable threads')
    
    if not re.findall('\n'.join(expected), r.qemu.output, re.M):
        raise AssertionError('Output does not match expected output')
  

@test(2, "uthread_3")
def test_uthread_3():
    r.run_qemu(shell_script([
        'uthread_ex3'
    ]))
    # 1. Start with the initial startup messages
    expected = ['thread_a started', 'thread_b started', 'thread_c started']
    
    # 2. Add thread_a's end
    expected.append('thread_a: exit after 3')

    # 3. Add all threads sleeping, then the scheduler waking them all up
    expected.append('only thread sleepings, wake them all')
    
    # 4. Add thread_b's end
    expected.append('thread_b: exit after 3')

    # 5. Add all threads sleeping, then the scheduler waking them all up
    expected.append('only thread sleepings, wake them all')

    # 6. Add thread_c's end
    expected.append('thread_c: exit after 3')

    # 7. Add the final scheduler message
    expected.append('thread_schedule: no runnable threads')
    
    if not re.findall('\n'.join(expected), r.qemu.output, re.M):
        raise AssertionError('Output does not match expected output')        

        
run_tests()

